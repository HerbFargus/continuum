This is a file of notes to the source code of Continuum.MOVE_AND_DISPLAY	This routine gives a good top-level view of how the game works.  It'shard to understand why things are the way they are, so here's what happens:1.  Some counters are decremented and their effects gauged.  For instance,once the ship dies there is a certain period of time (counted by dead_count)during which action goes on without the ship there, and at the end a newship is created.2.  We find out what keys the player is pressing, move the ship (adjustingthe screen position on the world if necessary), and clear the screenwe'll be drawing to (back_screen).3.  We draw things that should go under the ship without destroying it: fuel cells and craters.4.  We re-assert the gray background pattern in the ship's shadow positionby OR'ing a gray-masked shadow in the correct place.  This is so that a shadow will show up on white areas in the fuel cells and craters.5.  We draw all the white pieces of walls ("terrain" for historical reasons)that can't be drawn along with the black tops of the walls.  If this erasesthe gray-shadow, that part will "disappear" behind the wall; see #10.6.  We draw the phantom walls, since they should erase the shadow of theship, but should otherwise just go under the ship.7.  We erase under the ship, to allow for bounce detection in #8.8.  We call check_for_bounce, which draws all the bouncing walls, then checks whether any dots under the ship have been turned on, which wouldmean we need to find which wall and bounce the ship.9.  Next, we draw all the things on which the ship should explode if ithits them:  normal walls, bunkers, and enemy bullets if we're notshielding (draw them later if we are: #11).10.  Finally we draw the ship for real.  If there are any dots set underit, destroy it.  Draw the shadow by shifting the background gray-patternin the shadow position one dot, thereby allowing the shadow to disappearunder the walls.11.  Lastly, we draw a bunch of things that should go over the top of theship and/or never intersect with the ship:  shipshots, enemy bulletsif the shield is on, the shield, the flame behind the ship, explosions(both sparks and shards), and strafes (the little explosions of bulletson visible sides of walls).12.  Update the status bar if we need to as a result of changes that happened this round or the previous one.JUNCTIONS	This file holds a bunch of ad-hoc and ugly code to deal with all ofthe cases of walls intersecting when they can't be drawn independently.This is true at certain junctions; in general each wall is drawn as aspecially-handled start piece, a general and fast center, and a specialend.  A general way to draw the walls is to draw all the white first,then draw the black tops afterward.  This was done originally, but it'snot as fast as doing both at once; the optimization is ugly, but wasnecessary.  The white-then-black method is still used at some intersections.SHIFTED INTEGERS	There are quite a few places where integers are shifted left or right,then some calculations are performed, then they're shifted back.  This isto allow better-than-integer precision during the calculations.  Sometimesthese values are stored in records of objects to allow for smoothermovement or better accuracy.  Unfortunately, I don't use the same amountof shifting everywhere, since some accuracy is more important (like theship) and some numbers allow more shifting without going over themaximum they can hold.  I think I use mainly 3 and 4 for shards anddots (bullets, sparks, etc), while the ship uses an extra 8-bit amountto smooth its motion.MAC II	On a Macintosh II, or basically anything with a 68020 or bigger init, the program goes into emulation mode.  It allocates a second screenbuffer in memory, and then treats it as the back screen always, so alldrawing commmands go into it.  Then instead of switching screens, itdoes a CopyBits into a window on the screen (aligned to a word boundaryin the screen pixels, or Quickdraw would be too slow for this part).  TheCopyBits will hopefully remain compatible with all future systems, etc;Continuum thus gets to break all the rules on a Mac, while needing fewchanges to work on a Mac II.  We might redo this sometime to allowhigher performance on the II (we'll need it with color, for instance).